import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

// Load Env Vars
dotenv.config();

const supabaseUrl = process.env.VITE_SUPABASE_URL;
const supabaseAnonKey = process.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
    console.error("VITE_SUPABASE_URL or VITE_SUPABASE_ANON_KEY not set in .env");
    process.exit(1);
}

console.log("URL:", supabaseUrl);
console.log("Key (Prefix):", supabaseAnonKey.substring(0, 15) + "...");

// âš ï¸ simulates a Hacker using the Public Key from the browser
const attackerClient = createClient(supabaseUrl, supabaseAnonKey);

async function checkConnection() {
    console.log("... Verificando conectividade bÃ¡sica ...");
    const { data, error } = await attackerClient.from('stores').select('count', { count: 'exact', head: true });
    if (error) {
        console.error("âŒ ConexÃ£o Falhou:", error.message);
        process.exit(1);
    }
    console.log("âœ… ConexÃ£o Estabelecida. Iniciando ataques...");
}

async function performPentest() {
    await checkConnection();
    console.log("ðŸ˜ˆ INICIANDO PENTEST AUTOMATIZADO (SimulaÃ§Ã£o de Atacante) ðŸ˜ˆ");
    console.log("---------------------------------------------------------------");

    // 1. Tentar extrair todos os usuÃ¡rios (PII Leak)
    console.log("\n[TESTE 1] Tentando extrair base de usuÃ¡rios (Tabela 'users')...");
    const { data: users, error: userError } = await attackerClient.from('users').select('*');

    if (userError) {
        console.log("âœ… FALHA: O banco protegeu os dados de usuÃ¡rio.");
    } else {
        console.log("âŒ VULNERABILIDADE CRÃTICA: Dados de usuÃ¡rios expostos publicamente via RLS!");
        console.log(`   -> Recuperados ${users.length} registros.`);
        console.table(users.map(u => ({ id: u.id, email: u.email, role: u.role })));
    }

    // 2. Tentar extrair reclamaÃ§Ãµes de garantia (Business Data Leak)
    console.log("\n[TESTE 2] Tentando extrair todas as solicitaÃ§Ãµes de garantia...");
    const { data: claims, error: claimError } = await attackerClient.from('warranty_claims').select('*');

    if (claimError) {
        console.log("âœ… FALHA: O banco protegeu os dados de chamados.");
    } else {
        console.log("âŒ VULNERABILIDADE CRÃTICA: Dados de garantia expostos!");
        console.log(`   -> Recuperados ${claims.length} registros que deveriam ser privados.`);
        console.table(claims.map(c => ({ protocol: c.protocol_number, customer: c.customer_name, status: c.status })));
    }

    // 3. Tentar inserir um chamado falso (Data Integrity Attack)
    console.log("\n[TESTE 3] Tentando injetar um chamado de garantia falso...");
    const fakeClaim = {
        protocol_number: 'HACKED-' + Math.floor(Math.random() * 9999),
        status: 'APROVADO', // Tentar forÃ§ar status aprovado
        customer_name: 'Hacker',
        customer_phone: '000',
        item_type: 'Fake',
        product_description: 'Fake Item',
        serial_number: '000',
        invoice_number: '000',
        purchase_store_name: 'Fake Store',
        link_status: 'LINKED_AUTO' // Bypass de enums
    };

    const { data: insertData, error: insertError } = await attackerClient
        .from('warranty_claims')
        .insert([fakeClaim])
        .select();

    if (insertError) {
        console.log("âœ… FALHA: O banco impediu a inserÃ§Ã£o nÃ£o autorizada."); // Isso falharÃ¡ se RLS permitir Insert
        // Nota: O RLS permissivo pode permitir insert se a policy for "FOR ALL USING (true) WITH CHECK (true)"
        console.log("   -> Erro:", insertError.message);
    } else {
        console.log("âŒ VULNERABILIDADE CRÃTICA: InjeÃ§Ã£o de dados permitida sem autenticaÃ§Ã£o!");
        console.log("   -> Registro criado com ID:", insertData[0].id);
    }
}

performPentest();
